var KBBuffer = require('./KBBuffer').KBBuffer;

exports.encodeValue = function(aChar) {
    if (aChar < 26) {
        return String.fromCharCode(aChar + 0x41);
    } else if (aChar < 52) {
        return String.fromCharCode(aChar + 0x61 - 26);
    } else if (aChar < 62) {
        return String.fromCharCode(aChar + 0x30 - 52);
    } else {
        return ['+', '/'][aChar - 62];
    }
}

exports.decodeValue = function(aChar) {
    var number = aChar.charCodeAt(0);
    if (number >= 'A'.charCodeAt(0) && number <= 'Z'.charCodeAt(0)) {
        return number - 0x41;
    } else if (number >= 'a'.charCodeAt(0) && number <= 'z'.charCodeAt(0)) {
        return number - 0x61 + 26;
    } else if (number >= '0'.charCodeAt(0) && number <= '9'.charCodeAt(0)) {
        return number - 0x30 + 52;
    } else {
        return ['+', '/'].indexOf(number) + 62;
    }
}

exports.encodeGroup = function(triple) {
    var numbers = [triple[0] >> 2, 
                   (triple[1] >> 4) | ((triple[0] & 3) << 4),
                   (triple[2] >> 6) | ((triple[1] & 15) << 2),
                   triple[2] & 63];
    var str = '';
    for (var i = 0; i < numbers.length; i++) {
        var number = numbers[i];
        str += exports.encodeValue(number);
    }
    return str;
}

exports.decodeGroup = function(group) {
    var value = [];
    for (var i = 0; i < group.length; i++) {
        value.push(exports.decodeValue(group[i]));
    }
    return [(value[0] << 2) | (value[1] >> 4),
            ((value[1] & 15) << 4) | (value[2] >> 2),
            ((value[2] & 3) << 6) | value[3]];
}

exports.encode = function(buffer) {
    if (typeof buffer != 'object') {
        throw 'Invalid input type';
    }
    if (buffer.constructor.name != 'KBBuffer') {
        throw 'Invalid input class';
    }
    // encode each set of 3 bytes
    var encoded = '';
    for (var i = 0; i < buffer.length; i += 3) {
        var nextGroup = []; // the next group of 3 bytes
        var groupLen = i + 3 > buffer.length ? buffer.length - i : 3;
        
        for (var j = 0; j < groupLen; j++) {
            nextGroup.push(buffer.array[i + j]);
        }
        
        // encode next group
        var value = exports.encodeGroup(nextGroup);
        value = value.substring(0, groupLen + 1);
        if (groupLen == 1) value += '==';
        else if (groupLen == 2) value += '=';
        encoded += value;
    }
    return encoded;
}

exports.decode = function(string) {
    if (typeof string != 'string') {
        throw 'Invalid input type';
    }
    // the string's length must be divisible by 4
    if (string.length % 4 != 0) return null;
    var buff = new KBBuffer();
    for (var i = 0; i < string.length; i += 4) {
        var groupCode = string.substring(i, i + 4);
        var resultLen = 3;
        if (groupCode[3] == '=') {
            groupCode[3] = 'A';
            resultLen = 2;
        }
        if (groupCode[2] == '=') {
            groupCode[2] = 'A';
            resultLen = 1;
        }
        var result = exports.decodeGroup(groupCode);
        buff.write(result[0]);
        if (resultLen >= 2) buff.write(result[1]);
        if (resultLen == 3) buff.write(result[2]);
    }
    return buff;
}
