var db = require('./db');

exports.idLength = 16;

// general objects
var objectIdList = {'ids': ['id']}

// Account Sync Objects
var accountAttrNames = db.account.attributes;
var accountAttributes = {};
var accountAttributesOptional = {};
for (var i = 0; i < accountAttrNames.length; i++) {
    var attribute = accountAttrNames[i];
    accountAttributesOptional['@' + attribute] = 'data';
    accountAttributes[attribute] = 'data';
}

// Puzzle Sync Objects
var puzzleAttrNames = db.puzzle.localAttributes.concat(db.puzzle.globalAttributes);
var puzzleAttributes = {};
for (var i = 0; i < puzzleAttrNames.length; i++) {
    var attribute = puzzleAttrNames[i];
    puzzleAttributes[attribute] = 'data';
}
var objectPuzzle = {'id': 'id', 'attributes': puzzleAttributes};
var objectConflict = {'remotePuzzle': objectPuzzle, 'localId': 'id'};
var objectRename = {'id': 'id', 'name': 'string'};

// Session Sync Objects
var objectSolve = {'scramble': 'string', 'date': 'number', 'status': 'int',
                   'time': 'number', 'inspectionTime': 'number'};
var objectSession = {'puzzleId': 'data', 'solves': [objectSolve]};
var objectHashes = {'idPrefix': 'data', 'length': 'int', 'hashes': {'[data]': 'data'}};

var apiCalls = {
    'puzzles': {
        'add': {'puzzles': [objectPuzzle]},
        'replace': {'remoteId': 'id', 'puzzle': objectPuzzle},
        'renameThenAdd': {'remoteId': 'id', 'name': 'string', 'puzzle': objectPuzzle},
        'rename': {'renames': [objectRename]},
        'deleteThenRename': {'deleteId': 'id', 'rename': objectRename},
        'setValues': {'sets': [{'id': 'id', 'attribute': 'string', 'value': 'data'}]},
        'delete': objectIdList,
        'list': {},
        'myOrder': objectIdList
    },
    'sessions': {
        'delete': objectIdList,
        'add': {'sessions': [objectSession]},
        'getHashes': {'idPrefix': 'data', 'length': 'int'},
        'getDiff': {'idPrefix': 'data', 'ids': ['id']}
    },
    'account': {
        'setValues': {'attributes': accountAttributesOptional},
        'getAccount': {},
        'signin': {},
        'signup': {'email': 'string',
                   'attributes': accountAttributes},
        'setHash': {'new': 'data'},
        'setEmail': {'email': 'string'}
    },
    'image': {
        'upload': {'data': 'data', 'hash': 'data'},
        'download': {'hash': 'data'},
        'missing': {}
    }
};

/**
 * Specific Validation
 */

function validatePuzzleSet(data) {
    for (var i = 0; i < data['sets'].length; i++) {
        var setObj = data['sets'][i];
        var attribute = setObj['attribute'];
        if (db.puzzle.globalAttributes.indexOf(attribute) < 0) {
            if (db.puzzle.localAttributes.indexOf(attribute) < 0) {
                return false;
            }
        }
    }
    return true;
}

function validateAccountSet(data) {
    for (var i = 0; i < data['attributes'].length; i++) {
        var setObj = data['attributes'][i];
        var attribute = setObj['attribute'];
        if (db.account.attributes.indexOf(attribute) < 0) {
            return false;
        }
    }
    return true;
}

var specificValidation = {
    'puzzles.setValues': validatePuzzleSet,
    'account.setValues': validateAccountSet
};

function lookupAPICall(name) {
    var list = name.split('.');
    if (list.length != 2) return null;
    if (!apiCalls[list[0]]) {
        return null;
    }
    if (!apiCalls[list[0]][list[1]]) {
        return null;
    }
    return apiCalls[list[0]][list[1]];
}

function validateAPICallType(name, obj) {
    var expectedObj = lookupAPICall(name);
    if (!expectedObj) return false;
    
    // general validation
    if (!validateValue(obj, expectedObj)) return false;
    
    // specific validation
    if (!specificValidation[name]) return true;
    return specificValidation[name](obj);
}

function validateValue(object, type) {
    if (typeof type == 'object') {
        // its a dictionary
        if (typeof object != 'object') {
            return false;
        }
        return validateObject(object, type);
    } else if (typeof type == 'string') {
        if (type == 'data') {
            if (typeof object != 'object') return false;
            if (object.constructor.name != 'KBBuffer') return false;
            return true;
        } else if (type == 'id') {
            if (typeof object != 'object') return false;
            if (object.constructor.name != 'KBBuffer') return false;
            if (object.length != exports.idLength) return false;
            return true;
        } else return (type == typeof object);
    }
}

/*** Validation For Objects ***/

function validateObject(dict, types) {
    if (validateObjectIsAttributeList(types)) {
        return validateAttributeList(dict, types);
    } else {
        // confirm each property of `types` on dict
        for (var key in types) {
            // if key begins with '@' then it is an optional parameter
            var rawKey = key;
            if (key[0] == '@') rawKey = key.substring(1);
            if (dict[rawKey] == undefined) {
                if (rawKey == key) return false;
                else continue;
            }
            if (!validateValue(dict[rawKey], types[key])) return false;
        }
        // make sure they didn't send any excess keys
        for (var key in dict) {
            if (key[0] == '@') return false; // this is just funny business!
            if (types[key] == undefined && types['@' + key] == undefined) {
                return false;
            }
        }
        return true;
    }
}

function validateObjectIsAttributeList(types) {
    var keys = Object.keys(types);
    if (keys.length == 1) {
        // check if its an array type
        if (keys[0].length > 2) {
            var key = keys[0];
            if (key[0] == '[' && key[key.length - 1] == ']') {
                return true;
            }
        }
    }
    return false;
}

function validateAttributeList(dict, types) {
    var key = Object.keys(types)[0];
    var keyType = key.substring(1, key.length);
    var valType = types[key];
    for (var dictKey in dict) {
        if (!validateValue(dictKey, keyType)) return false;
        if (!validateValue(dict[dictKey], valType)) return false;
    }
}

exports.validateCall = validateAPICallType;
exports.validateValue = validateValue;
