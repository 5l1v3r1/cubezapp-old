var conn = require('./conn.js');
var mongo = require('mongodb');
var convert = require('./convert.js');

function Account(dictionary) {
    this.dictionary = dictionary;
}

/**
 * Tells callback(err, list) an array of [ObjectID] values
 * which are the unordered list of puzzles linked with
 * an account.
 */
Account.prototype.findPuzzleList = function(callback) {
    var account = this;
    conn.withDb(function (err1, db) {
        if (err1) {
            callback(err1, null);
            return;
        }
        // find the list of puzzles linked to the account
        var puzzles = db.collection('puzzles');
        var query = {'account': account.dictionary['_id']};
        var fields = {'_id': true};
        puzzles.find(query, fields).toArray(function (err2, list) {
            if (err2) {
                callback(err2, null);
                return;
            }
            var idList = [];
            for (var i = 0; i < list.length; i++) {
                idList.push(list[i]['_id']);
            }
            callback(null, idList);
        });
    });
}

/**
 * Tells callback(err, list) a specifically ordered array of [ObjectID]
 * values of puzzles on a certain device. If the device was not already
 * registered with the account, it will be added and a default order 
 * will be chosen. The device ID at the moment must be from this list:
 * - 'ios'
 */
Account.prototype.findOrderedPuzzles = function(device, callback) {
    var existing = this.dictionary.puzzleLists[device];
    if (existing != null && existing != undefined) {
        callback(null, existing);
        return;
    }
    
    // find the complete puzzle list and add it as a field
    var account = this;
    this.findPuzzleList(function (err1, list) {
        if (err1) {
            callback(err1, null);
            return;
        }
        conn.withDb(function (err2, db) {
            if (err2) {
                callback(err2, null);
                return;
            }
            var accounts = db.collection('accounts');
            var query = {'_id': account.dictionary['_id'], };
            var addKey = 'puzzleList.' + device;
            var set = {'$set': {addKey: list}}
            accounts.update(query, set, {'safe': true}, function (err3) {
                if (err3) {
                    callback(err3, null);
                    return;
                }
                account.puzzleLists[device] = list;
                callback(null, list);
            });
        });
    });
}

Account.prototype.getUsername = function() {
    return this.dictionary.username;
}

Account.prototype.getPassword = function() {
    return convert.convertData(this.dictionary.hash, 'KBBuffer');
}

Account.prototype.getEmail = function() {
    return this.dictionary.email;
}

Account.prototype.getAttribute = function(attr) {
    var rawValue = this.dictionary['attributes'][attr];
    return convert.convertData(rawValue, 'KBBuffer');
}

Account.prototype.setField = function(field, value, updateAcct, callback) {
    // set it in the database and then return
    var account = this;
    conn.withDb(function (err1, db) {
        if (err1) {
            callback(err1);
            return;
        }
        var accounts = db.collection('accounts');
        var query = {'_id': account.dictionary['_id']};
        accounts.update(query, {'$set': {field: value}}, {'safe': true}, function (err2) {
            if (err2) {
                callback(err2);
                return;
            }
            if (updateAcct) account[field] = value;
            callback(null);
        });
    });
}

Account.prototype.setEmail = function(email, callback) {
    this.setField('email', email, true, callback);
}

Account.prototype.setPassword = function(hash, callback) {
    var encoded = convert.convertData(hash, 'Binary');
    this.setField('hash', encoded, true, callback);
}

Account.prototype.setAttribute = function(attr, value, callback) {
    var account = this;
    var encodedValue = convert.convertData(value, 'Binary');
    this.setField('attributes.' + attr, encodedValue, false, function (err, val) {
        if (err == null) account.attributes[attr] = val;
        callback(err, val);
    });
}

exports.find = function(username, callback) {
    conn.withDb(function (err1, db) {
        if (err1) {
            callback(err1, null);
            return;
        }
        var accounts = db.collection('accounts');
        accounts.find({'username': username}).toArray(function (err2, list) {
            if (err2) {
                callback(err2, null);
                return;
            }
            if (list.length != 1) {
                callback(new Error('User not found'), null);
            } else {
                callback(null, new Account(list[0]));
            }
        });
    });
}

exports.signup = function(username, hash, email, attributes, callback) {
    conn.withDb(function (err1, db) {
        if (err1) {
            callback(err1, null);
            return;
        }
        var attrs = {};
        for (var key in attributes) {
            attrs[key] = convert.convertData(attributes[key], 'Binary');
        }
        var account = {'username': username,
                       'hash': convert.convertData(hash, 'Binary'),
                       'email': email,
                       'attributes': attrs};
        var accounts = db.collection('accounts');
        accounts.insert(account, {'safe': true}, function (err2, doc) {
            if (err2) {
                callback(err2, null);
                return;
            }
            callback(null, new Account(doc));
        });
    });
}

exports.Account = Account;
