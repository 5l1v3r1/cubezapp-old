var conn = require('./conn.js');
var mongo = require('mongodb');
var convert = require('./convert.js');

function keypathBase(keyPath) {
    var comps = keyPath.split('.');
    return comps[comps.length - 1];
}

function DbObject(dictionary, db) {
    this.db = db;
    this.dictionary = dictionary;
}

DbObject.prototype.lookupKeypathParent = function(field) {
    var components = field.split('.');
    var currentObj = this.dictionary;
    for (var i = 0; i < components.length - 1; i++) {
        currentObj = currentObj[components[i]];
        if (!currentObj) break;
    }
    return currentObj;
}

// this method should be implemented in a subclass
DbObject.prototype.getCollectionName = function() {
    return null;
}

DbObject.prototype.setField = function(field, value, callback) {
    // set it in the database and then return
    var dbObj = this;
    var collection = this.db.collection(this.getCollectionName());
    var query = {'_id': this.dictionary['_id']};
    var useValue = value;
    if (typeof useValue == 'object') {
        if (useValue.constructor.name == 'KBBuffer') {
            useValue = convert.convertData(useValue, 'Binary');
        }
    }
    collection.update(query, {'$set': {field: useValue}}, {'safe': true}, function (err) {
        if (!err) {
            var object = dbObj.lookupKeypathParent(field);
            object[keypathBase(field)] = useValue;
        }
        callback(err);
    });
}

DbObject.prototype.getField = function(field) {
    var object = this.lookupKeypathParent(field);
    var retVal = object[keypathBase(field)];
    if (retVal instanceof mongo.Binary) {
        retVal = convert.convertData(retVal, 'KBBuffer');
    }
    return retVal;
}

DbObject.prototype.toJSON = function() {
    throw 'JSON encoding must be implemented in a sub-class';
}

exports.findOne = function(query, constructor, collection, callback) {
    conn.withDb(function (err1, db) {
        if (err1) {
            callback(err1, null);
            return;
        }
        var aCollection = db.collection(collection);
        aCollection.findOne(query, function (err2, doc) {
            if (err2) {
                callback(err2, null);
                return;
            }
            if (!doc) {
                callback(null, null);
            } else {
                callback(null, new constructor(doc, db));
            }
        });
    });
}

exports.find = function(query, constructor, collection, callback) {
    conn.withDb(function (err1, db) {
        if (err1) {
            callback(err1, null);
            return;
        }
        var aCollection = db.collection(collection);
        aCollection.find(query).toArray(function (err2, docs) {
            if (err2) {
                callback(err2, null);
                return;
            }
            var objects = docs.map(function (x) { return new constructor(x, db); });
            callback(null, objects);
        });
    });
}

exports.add = function(docs, constructor, collection, callback) {
    conn.withDb(function (err, db) {
        if (err) return callback(err, null);
        var aCollection = db.collection(collection);
        aCollection.insert(docs, {'safe': true}, function (err1, docs) {
            if (err1) return callback(err1, null);
            var objects = docs.map(function(x) { return new constructor(x, db); });
            callback(null, objects);
        });
    });
}

exports.addOne = function(doc, constructor, collection, callback) {
    exports.add([doc], constructor, collection, function (err, list) {
        if (err) callback(err, null);
        else callback(null, list[0]);
    })
}

exports.binaryInQuery = function(datas) {
    var binaryIds = puzzleIds.map(function(x) {
        return convert.convertData(x, 'Binary');
    });
    var inQuery = {'$in': binaryIds};
    return inQuery;
}

exports.DbObject = DbObject;
