var conn = require('./conn.js');
var convert = require('./convert.js');
var dbobject = require('./dbobject.js');
var puzzle = require('./puzzle.js');

function Session(dictionary, db) {
    dbobject.DbObject.call(this, dictionary, db);
}

exports.find = function(accountId, sessionIds, callback) {
    var query = {'account': accountId, 
                 'id': dbobject.binaryInQuery(sessionIds)};
    dbobject.find(query, Session, 'sessions', callback);
}

exports.findOne = function(accountId, sessionId, callback) {
    var query = {'account': accountId, 
                 'id': convert.convertData(sessionId, 'Binary')};
    dbobject.find(query, Session, 'sessions', callback);
}

exports.findPrefix = function(accountId, sessionPref, callback) {
    var prefLen = 16;
    var prefix = convert.convertData(sessionPref, 'Binary');
    if (prefix.length() > prefLen) return callback(null, []);
    var lowerBound = new mongo.Binary(prefix.read(0, prefix.length()));
    var upperBound = new mongo.Binary(prefix.read(0, prefix.length()));
    for (var i = prefix.length(); i < prefLen; i++) {
        lowerBound.put(0x0);
        upperBound.put(0xff);
    }
    var boundary = [{'id': {'$gte': lowerBound}},
                    {'id': {'$lte': upperBound}}];
    var query = {'$and': boundary, 'account': accountId};
    return dbobject.find(query, Session, 'sessions', callback);
}

exports.add = function(accountId, sessionInfos, callback) {
    var documents = sessionInfos.map(function(x) {
        return encodeSession(accountId, x);
    });
    dbobject.add(documents, Session, 'sessions', function (err, objects) {
        // create a map of sessions for each puzzle ID and then verify
        // the puzzles' existance
        if (err) return callback(err);
        var objsForPuzzle = {};
        var puzzleIds = [];
        for (var i = 0; i < objects.length; i++) {
            var puzzleId = objects[i].dictionary['puzzleId'];
            var theKey = convert.convertData(puzzleId, 'Buffer').toString('hex');
            var array = objsForPuzzle[theKey];
            if (!array) {
                array = [objects[i]];
                objsForPuzzle[theKey] = array;
                puzzleIds.push(theKey);
            } else {
                array.push(objects[i]);
            }
        }
        verifyPuzzlesExist(puzzleIds, objsForPuzzle, callback);
    });
}

exports.deleteAll = function(accountId, sessionIds, callback) {
    var inQuery = dbobject.binaryInQuery(sessionIds);
    conn.withDb(function (err, db) {
        if (err) return callback(err);
        var sessions = db.collection('sessions');
        sessions.remove({'account': accountId, 'id': inQuery}, function (err1) {
            callback(err1);
        });
    });
}

/*** Utility Functions ***/

function encodeSession(accountId, sessionInfo) {
    return {'account': accountId, 
            'puzzleId': convert.convertData(sessionInfo['puzzleId'], 'Binary'),
            'id': convert.convertData(sessionInfo['id'], 'Binary'),
            'solves': sessionInfo['solves']};
}

function findDeletedSessions(puzzleIds, puzzles, sessionMap) {
    var deleteSessions = [];
    for (var i = 0; i < puzzleIds.length; i++) {
        var puzzleId = puzzleIds[i];
        var contains = false;
        // see if puzzles contains it
        for (var j = 0; j < puzzles.length; j++) {
            var aPuzzleId = puzzles[j].dictionary['id'];
            var puzzleIdStr = convert.convertData(aPuzzleId, 'Buffer').toString('hex');
            if (puzzleId == puzzleIdStr) {
                contains = true;
                break;
            }
        }
        if (contains) continue;
        deleteSessions = deleteSession.concat(sessionMap[puzzleId]);
        delete sessionMap[puzzleId];
    }
    return deleteSessions;
}

function verifyPuzzlesExist(accountId, puzzleIds, sessionMap, callback) {
    // verify the puzzle ids
    puzzle.find(accountId, puzzleIds, function (err, puzzles) {
        if (err) return callback(err, null);
        var deleteSessions = findDeletedSessions(puzzleIds, puzzles, sessionMap);
        
        var joinedSessions = [];
        for (var key in sessionMap) {
            joinedSessions = joinedSession.concat(sessionMap[key]);
        }
        
        if (deleteSessions.length > 0) {
            // delete all sessions and then run callback
            exports.deleteAll(accountId, deleteSessions, function (err1) {
                if (err1) return callback(err1, null);
                callback(null, joinedSessions);
            })
        } else {
            callback(null, joinSessions);
        }
    });
}
